Flask Toolbox
=============

Utilities for jumpstarting a RESTful PlanGrid service.


Summary
-------

What you get:

**Request and Response Validation** - Flask-toolbox is designed to work with [marshmallow](https://marshmallow.readthedocs.io/en/latest/) and is packaged with some common additions (e.g. validating against unexpected fields in request bodies).

**Authentication** - More specifically... lightweight backend service authentication.

**Error Handling** - All you need to do to get a proper JSON HTTP error response is throw an exception.

**Bugsnag Configuration** - Flask-toolbox forwards uncaught exceptions to Bugsnag.

**Healthcheck** - Kubernetes expects a healthcheck to know if a service was properly deployed - flask-toolbox includes one out of the box.

**Automatic Swagger Generation** - No need to manually maintain a massive .yaml file.
___

What you don't get:

**Auto-generated CRUD** - Flask-toolbox tries to be fairly un-opinionated, and doesn't make any assumptions about a service's database or business logic.

**Guaranteed Adherence to PlanGrid API Standards** - It's still up to you to make sure we're staying consistent with how PlanGrid does REST. As those standards become more and more finalized, flask-toolbox can start enforcing them.

**Content Negotiation** - Just application/json for now


TODO
----

[ ] CI pipeline to autogenerate Python clients from autogenerated Swagger
[ ] Make error handling with i18n, error codes, etc easy as pie
[ ] Higher level abstraction on top of handlers to make creating a PlanGrid-flavored REST service hard to get wrong


Installation
------------

This package is deployed to our local Python package index.

```
pip install plangrid.flask-toolbox
```


Example Usage
-------------

Check out the example app at [examples/todo.py](examples/todo.py). Some example requests to this example app can be found at [examples/todo_output.md](examples/todo_output.py).


Configuration
-------------

Flask-toolbox looks for the following environment variables:

| Environment Variable | Description | Default |
| -------------------- | ----------- | ------- |
| TOOLBOX_PAGINATION_LIMIT_MAX | The default page size limit for pagination requests. | `100` |
| BUGSNAG_API_KEY | The API key to use for notifying Bugsnag of errors. | `None` |
| BUGSNAG_RELEASE_STAGE | The release stage to use in Bugsnag notifications. | `production` |


Authentication
--------------

Flask-toolbox is designed for *internal* PlanGrid services, i.e. services inside our VPC, with requests from external clients proxied by an edge router.
Consequently, the only authentication mechanism included in this box is simple API key authentication, where all requests are assumed to be *internal and trusted*.

Clients may include an `X-PG-Auth` header, where the value is a shared secret. Clients may also include a `X-PG-UserId` header, where the value is a user object's unique identifier.

A Flask-toolbox application can be configured to be aware of multiple different API keys, making zero-downtime key rotation possible.
It can also be configured to associate different keys with different application, which can be useful for rudimentary application authorization.


Swagger Generation
------------------

Flask-toolbox can automatically generate a Swagger specification from the declarative routing of the `Framer`.
The same marshmallow schemas used to validate incoming requests and marshal outgoing data are used to generate the Swagger.

Converters for most of Marshmallow's fields and validators are included here.
The converters also inspect a Marshmallow schema/field/validator's method resolution order, so subclassing Marshmallow objects should work without much trouble.
With that, the Marshmallow to Swagger converter is extendable, allowing for custom handling of custom Marshmallow types.

*Under Construction - tutorial on a custom marshmallow_to_jsonschema Converter*
